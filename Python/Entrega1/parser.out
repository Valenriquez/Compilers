Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID ; vars funcs MAIN body END
Rule 2     vars -> VAR id_list : type ; vars
Rule 3     vars -> empty
Rule 4     id_list -> ID id_list_tail
Rule 5     id_list_tail -> , ID id_list_tail
Rule 6     id_list_tail -> empty
Rule 7     type -> INT
Rule 8     type -> FLOAT
Rule 9     funcs -> func funcs
Rule 10    funcs -> empty
Rule 11    func -> VOID ID ( params ) [ vars body ] ;
Rule 12    params -> ID : type params_tail
Rule 13    params -> empty
Rule 14    params_tail -> , ID : type params_tail
Rule 15    params_tail -> empty
Rule 16    body -> { stmt_list }
Rule 17    stmt_list -> statement stmt_list
Rule 18    stmt_list -> empty
Rule 19    statement -> assign
Rule 20    statement -> condition
Rule 21    statement -> cycle
Rule 22    statement -> f_call
Rule 23    statement -> print_stmt
Rule 24    assign -> ID = expression ;
Rule 25    print_stmt -> PRINT ( print_list ) ;
Rule 26    print_list -> print_item print_list_tail
Rule 27    print_item -> expression
Rule 28    print_item -> CTE_STRING
Rule 29    print_list_tail -> , print_item print_list_tail
Rule 30    print_list_tail -> empty
Rule 31    cycle -> WHILE ( expression ) DO body ;
Rule 32    condition -> IF ( expression ) body else_part ;
Rule 33    else_part -> ELSE body
Rule 34    else_part -> empty
Rule 35    f_call -> ID ( expr_list ) ;
Rule 36    expr_list -> expression expr_list_tail
Rule 37    expr_list -> empty
Rule 38    expr_list_tail -> , expression expr_list_tail
Rule 39    expr_list_tail -> empty
Rule 40    expression -> simple_expression
Rule 41    expression -> simple_expression > simple_expression
Rule 42    expression -> simple_expression < simple_expression
Rule 43    expression -> simple_expression NE simple_expression
Rule 44    simple_expression -> simple_expression + term
Rule 45    simple_expression -> simple_expression - term
Rule 46    simple_expression -> term
Rule 47    term -> term * factor
Rule 48    term -> term / factor
Rule 49    term -> factor
Rule 50    factor -> ( expression )
Rule 51    factor -> - factor
Rule 52    factor -> + factor
Rule 53    factor -> ID
Rule 54    factor -> CTE_INT
Rule 55    factor -> CTE_FLOAT
Rule 56    empty -> <empty>

Terminals, with rules where they appear

(                    : 11 25 31 32 35 50
)                    : 11 25 31 32 35 50
*                    : 47
+                    : 44 52
,                    : 5 14 29 38
-                    : 45 51
/                    : 48
:                    : 2 12 14
;                    : 1 2 11 24 25 31 32 35
<                    : 42
=                    : 24
>                    : 41
CTE_FLOAT            : 55
CTE_INT              : 54
CTE_STRING           : 28
DO                   : 31
ELSE                 : 33
END                  : 1
FLOAT                : 8
ID                   : 1 4 5 11 12 14 24 35 53
IF                   : 32
INT                  : 7
MAIN                 : 1
NE                   : 43
PRINT                : 25
PROGRAM              : 1
VAR                  : 2
VOID                 : 11
WHILE                : 31
[                    : 11
]                    : 11
error                : 
{                    : 16
}                    : 16

Nonterminals, with rules where they appear

assign               : 19
body                 : 1 11 31 32 33
condition            : 20
cycle                : 21
else_part            : 32
empty                : 3 6 10 13 15 18 30 34 37 39
expr_list            : 35
expr_list_tail       : 36 38
expression           : 24 27 31 32 36 38 50
f_call               : 22
factor               : 47 48 49 51 52
func                 : 9
funcs                : 1 9
id_list              : 2
id_list_tail         : 4 5
params               : 11
params_tail          : 12 14
print_item           : 26 29
print_list           : 25
print_list_tail      : 26 29
print_stmt           : 23
program              : 0
simple_expression    : 40 41 41 42 42 43 43 44 45
statement            : 17
stmt_list            : 16 17
term                 : 44 45 46 47 48
type                 : 2 12 14
vars                 : 1 2 11

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID ; vars funcs MAIN body END

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID ; vars funcs MAIN body END

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . ; vars funcs MAIN body END

    ;               shift and go to state 4


state 4

    (1) program -> PROGRAM ID ; . vars funcs MAIN body END
    (2) vars -> . VAR id_list : type ; vars
    (3) vars -> . empty
    (56) empty -> .

    VAR             shift and go to state 6
    VOID            reduce using rule 56 (empty -> .)
    MAIN            reduce using rule 56 (empty -> .)

    vars                           shift and go to state 5
    empty                          shift and go to state 7

state 5

    (1) program -> PROGRAM ID ; vars . funcs MAIN body END
    (9) funcs -> . func funcs
    (10) funcs -> . empty
    (11) func -> . VOID ID ( params ) [ vars body ] ;
    (56) empty -> .

    VOID            shift and go to state 11
    MAIN            reduce using rule 56 (empty -> .)

    funcs                          shift and go to state 8
    func                           shift and go to state 9
    empty                          shift and go to state 10

state 6

    (2) vars -> VAR . id_list : type ; vars
    (4) id_list -> . ID id_list_tail

    ID              shift and go to state 13

    id_list                        shift and go to state 12

state 7

    (3) vars -> empty .

    VOID            reduce using rule 3 (vars -> empty .)
    MAIN            reduce using rule 3 (vars -> empty .)
    {               reduce using rule 3 (vars -> empty .)


state 8

    (1) program -> PROGRAM ID ; vars funcs . MAIN body END

    MAIN            shift and go to state 14


state 9

    (9) funcs -> func . funcs
    (9) funcs -> . func funcs
    (10) funcs -> . empty
    (11) func -> . VOID ID ( params ) [ vars body ] ;
    (56) empty -> .

    VOID            shift and go to state 11
    MAIN            reduce using rule 56 (empty -> .)

    func                           shift and go to state 9
    funcs                          shift and go to state 15
    empty                          shift and go to state 10

state 10

    (10) funcs -> empty .

    MAIN            reduce using rule 10 (funcs -> empty .)


state 11

    (11) func -> VOID . ID ( params ) [ vars body ] ;

    ID              shift and go to state 16


state 12

    (2) vars -> VAR id_list . : type ; vars

    :               shift and go to state 17


state 13

    (4) id_list -> ID . id_list_tail
    (5) id_list_tail -> . , ID id_list_tail
    (6) id_list_tail -> . empty
    (56) empty -> .

    ,               shift and go to state 19
    :               reduce using rule 56 (empty -> .)

    id_list_tail                   shift and go to state 18
    empty                          shift and go to state 20

state 14

    (1) program -> PROGRAM ID ; vars funcs MAIN . body END
    (16) body -> . { stmt_list }

    {               shift and go to state 22

    body                           shift and go to state 21

state 15

    (9) funcs -> func funcs .

    MAIN            reduce using rule 9 (funcs -> func funcs .)


state 16

    (11) func -> VOID ID . ( params ) [ vars body ] ;

    (               shift and go to state 23


state 17

    (2) vars -> VAR id_list : . type ; vars
    (7) type -> . INT
    (8) type -> . FLOAT

    INT             shift and go to state 25
    FLOAT           shift and go to state 26

    type                           shift and go to state 24

state 18

    (4) id_list -> ID id_list_tail .

    :               reduce using rule 4 (id_list -> ID id_list_tail .)


state 19

    (5) id_list_tail -> , . ID id_list_tail

    ID              shift and go to state 27


state 20

    (6) id_list_tail -> empty .

    :               reduce using rule 6 (id_list_tail -> empty .)


state 21

    (1) program -> PROGRAM ID ; vars funcs MAIN body . END

    END             shift and go to state 28


state 22

    (16) body -> { . stmt_list }
    (17) stmt_list -> . statement stmt_list
    (18) stmt_list -> . empty
    (19) statement -> . assign
    (20) statement -> . condition
    (21) statement -> . cycle
    (22) statement -> . f_call
    (23) statement -> . print_stmt
    (56) empty -> .
    (24) assign -> . ID = expression ;
    (32) condition -> . IF ( expression ) body else_part ;
    (31) cycle -> . WHILE ( expression ) DO body ;
    (35) f_call -> . ID ( expr_list ) ;
    (25) print_stmt -> . PRINT ( print_list ) ;

    }               reduce using rule 56 (empty -> .)
    ID              shift and go to state 37
    IF              shift and go to state 38
    WHILE           shift and go to state 39
    PRINT           shift and go to state 40

    stmt_list                      shift and go to state 29
    statement                      shift and go to state 30
    empty                          shift and go to state 31
    assign                         shift and go to state 32
    condition                      shift and go to state 33
    cycle                          shift and go to state 34
    f_call                         shift and go to state 35
    print_stmt                     shift and go to state 36

state 23

    (11) func -> VOID ID ( . params ) [ vars body ] ;
    (12) params -> . ID : type params_tail
    (13) params -> . empty
    (56) empty -> .

    ID              shift and go to state 41
    )               reduce using rule 56 (empty -> .)

    params                         shift and go to state 42
    empty                          shift and go to state 43

state 24

    (2) vars -> VAR id_list : type . ; vars

    ;               shift and go to state 44


state 25

    (7) type -> INT .

    ;               reduce using rule 7 (type -> INT .)
    ,               reduce using rule 7 (type -> INT .)
    )               reduce using rule 7 (type -> INT .)


state 26

    (8) type -> FLOAT .

    ;               reduce using rule 8 (type -> FLOAT .)
    ,               reduce using rule 8 (type -> FLOAT .)
    )               reduce using rule 8 (type -> FLOAT .)


state 27

    (5) id_list_tail -> , ID . id_list_tail
    (5) id_list_tail -> . , ID id_list_tail
    (6) id_list_tail -> . empty
    (56) empty -> .

    ,               shift and go to state 19
    :               reduce using rule 56 (empty -> .)

    id_list_tail                   shift and go to state 45
    empty                          shift and go to state 20

state 28

    (1) program -> PROGRAM ID ; vars funcs MAIN body END .

    $end            reduce using rule 1 (program -> PROGRAM ID ; vars funcs MAIN body END .)


state 29

    (16) body -> { stmt_list . }

    }               shift and go to state 46


state 30

    (17) stmt_list -> statement . stmt_list
    (17) stmt_list -> . statement stmt_list
    (18) stmt_list -> . empty
    (19) statement -> . assign
    (20) statement -> . condition
    (21) statement -> . cycle
    (22) statement -> . f_call
    (23) statement -> . print_stmt
    (56) empty -> .
    (24) assign -> . ID = expression ;
    (32) condition -> . IF ( expression ) body else_part ;
    (31) cycle -> . WHILE ( expression ) DO body ;
    (35) f_call -> . ID ( expr_list ) ;
    (25) print_stmt -> . PRINT ( print_list ) ;

    }               reduce using rule 56 (empty -> .)
    ID              shift and go to state 37
    IF              shift and go to state 38
    WHILE           shift and go to state 39
    PRINT           shift and go to state 40

    statement                      shift and go to state 30
    stmt_list                      shift and go to state 47
    empty                          shift and go to state 31
    assign                         shift and go to state 32
    condition                      shift and go to state 33
    cycle                          shift and go to state 34
    f_call                         shift and go to state 35
    print_stmt                     shift and go to state 36

state 31

    (18) stmt_list -> empty .

    }               reduce using rule 18 (stmt_list -> empty .)


state 32

    (19) statement -> assign .

    ID              reduce using rule 19 (statement -> assign .)
    IF              reduce using rule 19 (statement -> assign .)
    WHILE           reduce using rule 19 (statement -> assign .)
    PRINT           reduce using rule 19 (statement -> assign .)
    }               reduce using rule 19 (statement -> assign .)


state 33

    (20) statement -> condition .

    ID              reduce using rule 20 (statement -> condition .)
    IF              reduce using rule 20 (statement -> condition .)
    WHILE           reduce using rule 20 (statement -> condition .)
    PRINT           reduce using rule 20 (statement -> condition .)
    }               reduce using rule 20 (statement -> condition .)


state 34

    (21) statement -> cycle .

    ID              reduce using rule 21 (statement -> cycle .)
    IF              reduce using rule 21 (statement -> cycle .)
    WHILE           reduce using rule 21 (statement -> cycle .)
    PRINT           reduce using rule 21 (statement -> cycle .)
    }               reduce using rule 21 (statement -> cycle .)


state 35

    (22) statement -> f_call .

    ID              reduce using rule 22 (statement -> f_call .)
    IF              reduce using rule 22 (statement -> f_call .)
    WHILE           reduce using rule 22 (statement -> f_call .)
    PRINT           reduce using rule 22 (statement -> f_call .)
    }               reduce using rule 22 (statement -> f_call .)


state 36

    (23) statement -> print_stmt .

    ID              reduce using rule 23 (statement -> print_stmt .)
    IF              reduce using rule 23 (statement -> print_stmt .)
    WHILE           reduce using rule 23 (statement -> print_stmt .)
    PRINT           reduce using rule 23 (statement -> print_stmt .)
    }               reduce using rule 23 (statement -> print_stmt .)


state 37

    (24) assign -> ID . = expression ;
    (35) f_call -> ID . ( expr_list ) ;

    =               shift and go to state 48
    (               shift and go to state 49


state 38

    (32) condition -> IF . ( expression ) body else_part ;

    (               shift and go to state 50


state 39

    (31) cycle -> WHILE . ( expression ) DO body ;

    (               shift and go to state 51


state 40

    (25) print_stmt -> PRINT . ( print_list ) ;

    (               shift and go to state 52


state 41

    (12) params -> ID . : type params_tail

    :               shift and go to state 53


state 42

    (11) func -> VOID ID ( params . ) [ vars body ] ;

    )               shift and go to state 54


state 43

    (13) params -> empty .

    )               reduce using rule 13 (params -> empty .)


state 44

    (2) vars -> VAR id_list : type ; . vars
    (2) vars -> . VAR id_list : type ; vars
    (3) vars -> . empty
    (56) empty -> .

    VAR             shift and go to state 6
    VOID            reduce using rule 56 (empty -> .)
    MAIN            reduce using rule 56 (empty -> .)
    {               reduce using rule 56 (empty -> .)

    vars                           shift and go to state 55
    empty                          shift and go to state 7

state 45

    (5) id_list_tail -> , ID id_list_tail .

    :               reduce using rule 5 (id_list_tail -> , ID id_list_tail .)


state 46

    (16) body -> { stmt_list } .

    END             reduce using rule 16 (body -> { stmt_list } .)
    ELSE            reduce using rule 16 (body -> { stmt_list } .)
    ;               reduce using rule 16 (body -> { stmt_list } .)
    ]               reduce using rule 16 (body -> { stmt_list } .)


state 47

    (17) stmt_list -> statement stmt_list .

    }               reduce using rule 17 (stmt_list -> statement stmt_list .)


state 48

    (24) assign -> ID = . expression ;
    (40) expression -> . simple_expression
    (41) expression -> . simple_expression > simple_expression
    (42) expression -> . simple_expression < simple_expression
    (43) expression -> . simple_expression NE simple_expression
    (44) simple_expression -> . simple_expression + term
    (45) simple_expression -> . simple_expression - term
    (46) simple_expression -> . term
    (47) term -> . term * factor
    (48) term -> . term / factor
    (49) term -> . factor
    (50) factor -> . ( expression )
    (51) factor -> . - factor
    (52) factor -> . + factor
    (53) factor -> . ID
    (54) factor -> . CTE_INT
    (55) factor -> . CTE_FLOAT

    (               shift and go to state 63
    -               shift and go to state 61
    +               shift and go to state 59
    ID              shift and go to state 56
    CTE_INT         shift and go to state 64
    CTE_FLOAT       shift and go to state 65

    expression                     shift and go to state 57
    simple_expression              shift and go to state 58
    term                           shift and go to state 60
    factor                         shift and go to state 62

state 49

    (35) f_call -> ID ( . expr_list ) ;
    (36) expr_list -> . expression expr_list_tail
    (37) expr_list -> . empty
    (40) expression -> . simple_expression
    (41) expression -> . simple_expression > simple_expression
    (42) expression -> . simple_expression < simple_expression
    (43) expression -> . simple_expression NE simple_expression
    (56) empty -> .
    (44) simple_expression -> . simple_expression + term
    (45) simple_expression -> . simple_expression - term
    (46) simple_expression -> . term
    (47) term -> . term * factor
    (48) term -> . term / factor
    (49) term -> . factor
    (50) factor -> . ( expression )
    (51) factor -> . - factor
    (52) factor -> . + factor
    (53) factor -> . ID
    (54) factor -> . CTE_INT
    (55) factor -> . CTE_FLOAT

    )               reduce using rule 56 (empty -> .)
    (               shift and go to state 63
    -               shift and go to state 61
    +               shift and go to state 59
    ID              shift and go to state 56
    CTE_INT         shift and go to state 64
    CTE_FLOAT       shift and go to state 65

    expr_list                      shift and go to state 66
    expression                     shift and go to state 67
    empty                          shift and go to state 68
    simple_expression              shift and go to state 58
    term                           shift and go to state 60
    factor                         shift and go to state 62

state 50

    (32) condition -> IF ( . expression ) body else_part ;
    (40) expression -> . simple_expression
    (41) expression -> . simple_expression > simple_expression
    (42) expression -> . simple_expression < simple_expression
    (43) expression -> . simple_expression NE simple_expression
    (44) simple_expression -> . simple_expression + term
    (45) simple_expression -> . simple_expression - term
    (46) simple_expression -> . term
    (47) term -> . term * factor
    (48) term -> . term / factor
    (49) term -> . factor
    (50) factor -> . ( expression )
    (51) factor -> . - factor
    (52) factor -> . + factor
    (53) factor -> . ID
    (54) factor -> . CTE_INT
    (55) factor -> . CTE_FLOAT

    (               shift and go to state 63
    -               shift and go to state 61
    +               shift and go to state 59
    ID              shift and go to state 56
    CTE_INT         shift and go to state 64
    CTE_FLOAT       shift and go to state 65

    expression                     shift and go to state 69
    simple_expression              shift and go to state 58
    term                           shift and go to state 60
    factor                         shift and go to state 62

state 51

    (31) cycle -> WHILE ( . expression ) DO body ;
    (40) expression -> . simple_expression
    (41) expression -> . simple_expression > simple_expression
    (42) expression -> . simple_expression < simple_expression
    (43) expression -> . simple_expression NE simple_expression
    (44) simple_expression -> . simple_expression + term
    (45) simple_expression -> . simple_expression - term
    (46) simple_expression -> . term
    (47) term -> . term * factor
    (48) term -> . term / factor
    (49) term -> . factor
    (50) factor -> . ( expression )
    (51) factor -> . - factor
    (52) factor -> . + factor
    (53) factor -> . ID
    (54) factor -> . CTE_INT
    (55) factor -> . CTE_FLOAT

    (               shift and go to state 63
    -               shift and go to state 61
    +               shift and go to state 59
    ID              shift and go to state 56
    CTE_INT         shift and go to state 64
    CTE_FLOAT       shift and go to state 65

    expression                     shift and go to state 70
    simple_expression              shift and go to state 58
    term                           shift and go to state 60
    factor                         shift and go to state 62

state 52

    (25) print_stmt -> PRINT ( . print_list ) ;
    (26) print_list -> . print_item print_list_tail
    (27) print_item -> . expression
    (28) print_item -> . CTE_STRING
    (40) expression -> . simple_expression
    (41) expression -> . simple_expression > simple_expression
    (42) expression -> . simple_expression < simple_expression
    (43) expression -> . simple_expression NE simple_expression
    (44) simple_expression -> . simple_expression + term
    (45) simple_expression -> . simple_expression - term
    (46) simple_expression -> . term
    (47) term -> . term * factor
    (48) term -> . term / factor
    (49) term -> . factor
    (50) factor -> . ( expression )
    (51) factor -> . - factor
    (52) factor -> . + factor
    (53) factor -> . ID
    (54) factor -> . CTE_INT
    (55) factor -> . CTE_FLOAT

    CTE_STRING      shift and go to state 74
    (               shift and go to state 63
    -               shift and go to state 61
    +               shift and go to state 59
    ID              shift and go to state 56
    CTE_INT         shift and go to state 64
    CTE_FLOAT       shift and go to state 65

    print_list                     shift and go to state 71
    print_item                     shift and go to state 72
    expression                     shift and go to state 73
    simple_expression              shift and go to state 58
    term                           shift and go to state 60
    factor                         shift and go to state 62

state 53

    (12) params -> ID : . type params_tail
    (7) type -> . INT
    (8) type -> . FLOAT

    INT             shift and go to state 25
    FLOAT           shift and go to state 26

    type                           shift and go to state 75

state 54

    (11) func -> VOID ID ( params ) . [ vars body ] ;

    [               shift and go to state 76


state 55

    (2) vars -> VAR id_list : type ; vars .

    VOID            reduce using rule 2 (vars -> VAR id_list : type ; vars .)
    MAIN            reduce using rule 2 (vars -> VAR id_list : type ; vars .)
    {               reduce using rule 2 (vars -> VAR id_list : type ; vars .)


state 56

    (53) factor -> ID .

    *               reduce using rule 53 (factor -> ID .)
    /               reduce using rule 53 (factor -> ID .)
    >               reduce using rule 53 (factor -> ID .)
    <               reduce using rule 53 (factor -> ID .)
    NE              reduce using rule 53 (factor -> ID .)
    +               reduce using rule 53 (factor -> ID .)
    -               reduce using rule 53 (factor -> ID .)
    ;               reduce using rule 53 (factor -> ID .)
    ,               reduce using rule 53 (factor -> ID .)
    )               reduce using rule 53 (factor -> ID .)


state 57

    (24) assign -> ID = expression . ;

    ;               shift and go to state 77


state 58

    (40) expression -> simple_expression .
    (41) expression -> simple_expression . > simple_expression
    (42) expression -> simple_expression . < simple_expression
    (43) expression -> simple_expression . NE simple_expression
    (44) simple_expression -> simple_expression . + term
    (45) simple_expression -> simple_expression . - term

    ;               reduce using rule 40 (expression -> simple_expression .)
    ,               reduce using rule 40 (expression -> simple_expression .)
    )               reduce using rule 40 (expression -> simple_expression .)
    >               shift and go to state 78
    <               shift and go to state 79
    NE              shift and go to state 80
    +               shift and go to state 81
    -               shift and go to state 82


state 59

    (52) factor -> + . factor
    (50) factor -> . ( expression )
    (51) factor -> . - factor
    (52) factor -> . + factor
    (53) factor -> . ID
    (54) factor -> . CTE_INT
    (55) factor -> . CTE_FLOAT

    (               shift and go to state 63
    -               shift and go to state 61
    +               shift and go to state 59
    ID              shift and go to state 56
    CTE_INT         shift and go to state 64
    CTE_FLOAT       shift and go to state 65

    factor                         shift and go to state 83

state 60

    (46) simple_expression -> term .
    (47) term -> term . * factor
    (48) term -> term . / factor

    >               reduce using rule 46 (simple_expression -> term .)
    <               reduce using rule 46 (simple_expression -> term .)
    NE              reduce using rule 46 (simple_expression -> term .)
    +               reduce using rule 46 (simple_expression -> term .)
    -               reduce using rule 46 (simple_expression -> term .)
    ;               reduce using rule 46 (simple_expression -> term .)
    ,               reduce using rule 46 (simple_expression -> term .)
    )               reduce using rule 46 (simple_expression -> term .)
    *               shift and go to state 84
    /               shift and go to state 85


state 61

    (51) factor -> - . factor
    (50) factor -> . ( expression )
    (51) factor -> . - factor
    (52) factor -> . + factor
    (53) factor -> . ID
    (54) factor -> . CTE_INT
    (55) factor -> . CTE_FLOAT

    (               shift and go to state 63
    -               shift and go to state 61
    +               shift and go to state 59
    ID              shift and go to state 56
    CTE_INT         shift and go to state 64
    CTE_FLOAT       shift and go to state 65

    factor                         shift and go to state 86

state 62

    (49) term -> factor .

    *               reduce using rule 49 (term -> factor .)
    /               reduce using rule 49 (term -> factor .)
    >               reduce using rule 49 (term -> factor .)
    <               reduce using rule 49 (term -> factor .)
    NE              reduce using rule 49 (term -> factor .)
    +               reduce using rule 49 (term -> factor .)
    -               reduce using rule 49 (term -> factor .)
    ;               reduce using rule 49 (term -> factor .)
    ,               reduce using rule 49 (term -> factor .)
    )               reduce using rule 49 (term -> factor .)


state 63

    (50) factor -> ( . expression )
    (40) expression -> . simple_expression
    (41) expression -> . simple_expression > simple_expression
    (42) expression -> . simple_expression < simple_expression
    (43) expression -> . simple_expression NE simple_expression
    (44) simple_expression -> . simple_expression + term
    (45) simple_expression -> . simple_expression - term
    (46) simple_expression -> . term
    (47) term -> . term * factor
    (48) term -> . term / factor
    (49) term -> . factor
    (50) factor -> . ( expression )
    (51) factor -> . - factor
    (52) factor -> . + factor
    (53) factor -> . ID
    (54) factor -> . CTE_INT
    (55) factor -> . CTE_FLOAT

    (               shift and go to state 63
    -               shift and go to state 61
    +               shift and go to state 59
    ID              shift and go to state 56
    CTE_INT         shift and go to state 64
    CTE_FLOAT       shift and go to state 65

    expression                     shift and go to state 87
    simple_expression              shift and go to state 58
    term                           shift and go to state 60
    factor                         shift and go to state 62

state 64

    (54) factor -> CTE_INT .

    *               reduce using rule 54 (factor -> CTE_INT .)
    /               reduce using rule 54 (factor -> CTE_INT .)
    >               reduce using rule 54 (factor -> CTE_INT .)
    <               reduce using rule 54 (factor -> CTE_INT .)
    NE              reduce using rule 54 (factor -> CTE_INT .)
    +               reduce using rule 54 (factor -> CTE_INT .)
    -               reduce using rule 54 (factor -> CTE_INT .)
    ;               reduce using rule 54 (factor -> CTE_INT .)
    ,               reduce using rule 54 (factor -> CTE_INT .)
    )               reduce using rule 54 (factor -> CTE_INT .)


state 65

    (55) factor -> CTE_FLOAT .

    *               reduce using rule 55 (factor -> CTE_FLOAT .)
    /               reduce using rule 55 (factor -> CTE_FLOAT .)
    >               reduce using rule 55 (factor -> CTE_FLOAT .)
    <               reduce using rule 55 (factor -> CTE_FLOAT .)
    NE              reduce using rule 55 (factor -> CTE_FLOAT .)
    +               reduce using rule 55 (factor -> CTE_FLOAT .)
    -               reduce using rule 55 (factor -> CTE_FLOAT .)
    ;               reduce using rule 55 (factor -> CTE_FLOAT .)
    ,               reduce using rule 55 (factor -> CTE_FLOAT .)
    )               reduce using rule 55 (factor -> CTE_FLOAT .)


state 66

    (35) f_call -> ID ( expr_list . ) ;

    )               shift and go to state 88


state 67

    (36) expr_list -> expression . expr_list_tail
    (38) expr_list_tail -> . , expression expr_list_tail
    (39) expr_list_tail -> . empty
    (56) empty -> .

    ,               shift and go to state 90
    )               reduce using rule 56 (empty -> .)

    expr_list_tail                 shift and go to state 89
    empty                          shift and go to state 91

state 68

    (37) expr_list -> empty .

    )               reduce using rule 37 (expr_list -> empty .)


state 69

    (32) condition -> IF ( expression . ) body else_part ;

    )               shift and go to state 92


state 70

    (31) cycle -> WHILE ( expression . ) DO body ;

    )               shift and go to state 93


state 71

    (25) print_stmt -> PRINT ( print_list . ) ;

    )               shift and go to state 94


state 72

    (26) print_list -> print_item . print_list_tail
    (29) print_list_tail -> . , print_item print_list_tail
    (30) print_list_tail -> . empty
    (56) empty -> .

    ,               shift and go to state 96
    )               reduce using rule 56 (empty -> .)

    print_list_tail                shift and go to state 95
    empty                          shift and go to state 97

state 73

    (27) print_item -> expression .

    ,               reduce using rule 27 (print_item -> expression .)
    )               reduce using rule 27 (print_item -> expression .)


state 74

    (28) print_item -> CTE_STRING .

    ,               reduce using rule 28 (print_item -> CTE_STRING .)
    )               reduce using rule 28 (print_item -> CTE_STRING .)


state 75

    (12) params -> ID : type . params_tail
    (14) params_tail -> . , ID : type params_tail
    (15) params_tail -> . empty
    (56) empty -> .

    ,               shift and go to state 99
    )               reduce using rule 56 (empty -> .)

    params_tail                    shift and go to state 98
    empty                          shift and go to state 100

state 76

    (11) func -> VOID ID ( params ) [ . vars body ] ;
    (2) vars -> . VAR id_list : type ; vars
    (3) vars -> . empty
    (56) empty -> .

    VAR             shift and go to state 6
    {               reduce using rule 56 (empty -> .)

    vars                           shift and go to state 101
    empty                          shift and go to state 7

state 77

    (24) assign -> ID = expression ; .

    ID              reduce using rule 24 (assign -> ID = expression ; .)
    IF              reduce using rule 24 (assign -> ID = expression ; .)
    WHILE           reduce using rule 24 (assign -> ID = expression ; .)
    PRINT           reduce using rule 24 (assign -> ID = expression ; .)
    }               reduce using rule 24 (assign -> ID = expression ; .)


state 78

    (41) expression -> simple_expression > . simple_expression
    (44) simple_expression -> . simple_expression + term
    (45) simple_expression -> . simple_expression - term
    (46) simple_expression -> . term
    (47) term -> . term * factor
    (48) term -> . term / factor
    (49) term -> . factor
    (50) factor -> . ( expression )
    (51) factor -> . - factor
    (52) factor -> . + factor
    (53) factor -> . ID
    (54) factor -> . CTE_INT
    (55) factor -> . CTE_FLOAT

    (               shift and go to state 63
    -               shift and go to state 61
    +               shift and go to state 59
    ID              shift and go to state 56
    CTE_INT         shift and go to state 64
    CTE_FLOAT       shift and go to state 65

    simple_expression              shift and go to state 102
    term                           shift and go to state 60
    factor                         shift and go to state 62

state 79

    (42) expression -> simple_expression < . simple_expression
    (44) simple_expression -> . simple_expression + term
    (45) simple_expression -> . simple_expression - term
    (46) simple_expression -> . term
    (47) term -> . term * factor
    (48) term -> . term / factor
    (49) term -> . factor
    (50) factor -> . ( expression )
    (51) factor -> . - factor
    (52) factor -> . + factor
    (53) factor -> . ID
    (54) factor -> . CTE_INT
    (55) factor -> . CTE_FLOAT

    (               shift and go to state 63
    -               shift and go to state 61
    +               shift and go to state 59
    ID              shift and go to state 56
    CTE_INT         shift and go to state 64
    CTE_FLOAT       shift and go to state 65

    simple_expression              shift and go to state 103
    term                           shift and go to state 60
    factor                         shift and go to state 62

state 80

    (43) expression -> simple_expression NE . simple_expression
    (44) simple_expression -> . simple_expression + term
    (45) simple_expression -> . simple_expression - term
    (46) simple_expression -> . term
    (47) term -> . term * factor
    (48) term -> . term / factor
    (49) term -> . factor
    (50) factor -> . ( expression )
    (51) factor -> . - factor
    (52) factor -> . + factor
    (53) factor -> . ID
    (54) factor -> . CTE_INT
    (55) factor -> . CTE_FLOAT

    (               shift and go to state 63
    -               shift and go to state 61
    +               shift and go to state 59
    ID              shift and go to state 56
    CTE_INT         shift and go to state 64
    CTE_FLOAT       shift and go to state 65

    simple_expression              shift and go to state 104
    term                           shift and go to state 60
    factor                         shift and go to state 62

state 81

    (44) simple_expression -> simple_expression + . term
    (47) term -> . term * factor
    (48) term -> . term / factor
    (49) term -> . factor
    (50) factor -> . ( expression )
    (51) factor -> . - factor
    (52) factor -> . + factor
    (53) factor -> . ID
    (54) factor -> . CTE_INT
    (55) factor -> . CTE_FLOAT

    (               shift and go to state 63
    -               shift and go to state 61
    +               shift and go to state 59
    ID              shift and go to state 56
    CTE_INT         shift and go to state 64
    CTE_FLOAT       shift and go to state 65

    term                           shift and go to state 105
    factor                         shift and go to state 62

state 82

    (45) simple_expression -> simple_expression - . term
    (47) term -> . term * factor
    (48) term -> . term / factor
    (49) term -> . factor
    (50) factor -> . ( expression )
    (51) factor -> . - factor
    (52) factor -> . + factor
    (53) factor -> . ID
    (54) factor -> . CTE_INT
    (55) factor -> . CTE_FLOAT

    (               shift and go to state 63
    -               shift and go to state 61
    +               shift and go to state 59
    ID              shift and go to state 56
    CTE_INT         shift and go to state 64
    CTE_FLOAT       shift and go to state 65

    term                           shift and go to state 106
    factor                         shift and go to state 62

state 83

    (52) factor -> + factor .

    *               reduce using rule 52 (factor -> + factor .)
    /               reduce using rule 52 (factor -> + factor .)
    >               reduce using rule 52 (factor -> + factor .)
    <               reduce using rule 52 (factor -> + factor .)
    NE              reduce using rule 52 (factor -> + factor .)
    +               reduce using rule 52 (factor -> + factor .)
    -               reduce using rule 52 (factor -> + factor .)
    ;               reduce using rule 52 (factor -> + factor .)
    ,               reduce using rule 52 (factor -> + factor .)
    )               reduce using rule 52 (factor -> + factor .)


state 84

    (47) term -> term * . factor
    (50) factor -> . ( expression )
    (51) factor -> . - factor
    (52) factor -> . + factor
    (53) factor -> . ID
    (54) factor -> . CTE_INT
    (55) factor -> . CTE_FLOAT

    (               shift and go to state 63
    -               shift and go to state 61
    +               shift and go to state 59
    ID              shift and go to state 56
    CTE_INT         shift and go to state 64
    CTE_FLOAT       shift and go to state 65

    factor                         shift and go to state 107

state 85

    (48) term -> term / . factor
    (50) factor -> . ( expression )
    (51) factor -> . - factor
    (52) factor -> . + factor
    (53) factor -> . ID
    (54) factor -> . CTE_INT
    (55) factor -> . CTE_FLOAT

    (               shift and go to state 63
    -               shift and go to state 61
    +               shift and go to state 59
    ID              shift and go to state 56
    CTE_INT         shift and go to state 64
    CTE_FLOAT       shift and go to state 65

    factor                         shift and go to state 108

state 86

    (51) factor -> - factor .

    *               reduce using rule 51 (factor -> - factor .)
    /               reduce using rule 51 (factor -> - factor .)
    >               reduce using rule 51 (factor -> - factor .)
    <               reduce using rule 51 (factor -> - factor .)
    NE              reduce using rule 51 (factor -> - factor .)
    +               reduce using rule 51 (factor -> - factor .)
    -               reduce using rule 51 (factor -> - factor .)
    ;               reduce using rule 51 (factor -> - factor .)
    ,               reduce using rule 51 (factor -> - factor .)
    )               reduce using rule 51 (factor -> - factor .)


state 87

    (50) factor -> ( expression . )

    )               shift and go to state 109


state 88

    (35) f_call -> ID ( expr_list ) . ;

    ;               shift and go to state 110


state 89

    (36) expr_list -> expression expr_list_tail .

    )               reduce using rule 36 (expr_list -> expression expr_list_tail .)


state 90

    (38) expr_list_tail -> , . expression expr_list_tail
    (40) expression -> . simple_expression
    (41) expression -> . simple_expression > simple_expression
    (42) expression -> . simple_expression < simple_expression
    (43) expression -> . simple_expression NE simple_expression
    (44) simple_expression -> . simple_expression + term
    (45) simple_expression -> . simple_expression - term
    (46) simple_expression -> . term
    (47) term -> . term * factor
    (48) term -> . term / factor
    (49) term -> . factor
    (50) factor -> . ( expression )
    (51) factor -> . - factor
    (52) factor -> . + factor
    (53) factor -> . ID
    (54) factor -> . CTE_INT
    (55) factor -> . CTE_FLOAT

    (               shift and go to state 63
    -               shift and go to state 61
    +               shift and go to state 59
    ID              shift and go to state 56
    CTE_INT         shift and go to state 64
    CTE_FLOAT       shift and go to state 65

    expression                     shift and go to state 111
    simple_expression              shift and go to state 58
    term                           shift and go to state 60
    factor                         shift and go to state 62

state 91

    (39) expr_list_tail -> empty .

    )               reduce using rule 39 (expr_list_tail -> empty .)


state 92

    (32) condition -> IF ( expression ) . body else_part ;
    (16) body -> . { stmt_list }

    {               shift and go to state 22

    body                           shift and go to state 112

state 93

    (31) cycle -> WHILE ( expression ) . DO body ;

    DO              shift and go to state 113


state 94

    (25) print_stmt -> PRINT ( print_list ) . ;

    ;               shift and go to state 114


state 95

    (26) print_list -> print_item print_list_tail .

    )               reduce using rule 26 (print_list -> print_item print_list_tail .)


state 96

    (29) print_list_tail -> , . print_item print_list_tail
    (27) print_item -> . expression
    (28) print_item -> . CTE_STRING
    (40) expression -> . simple_expression
    (41) expression -> . simple_expression > simple_expression
    (42) expression -> . simple_expression < simple_expression
    (43) expression -> . simple_expression NE simple_expression
    (44) simple_expression -> . simple_expression + term
    (45) simple_expression -> . simple_expression - term
    (46) simple_expression -> . term
    (47) term -> . term * factor
    (48) term -> . term / factor
    (49) term -> . factor
    (50) factor -> . ( expression )
    (51) factor -> . - factor
    (52) factor -> . + factor
    (53) factor -> . ID
    (54) factor -> . CTE_INT
    (55) factor -> . CTE_FLOAT

    CTE_STRING      shift and go to state 74
    (               shift and go to state 63
    -               shift and go to state 61
    +               shift and go to state 59
    ID              shift and go to state 56
    CTE_INT         shift and go to state 64
    CTE_FLOAT       shift and go to state 65

    print_item                     shift and go to state 115
    expression                     shift and go to state 73
    simple_expression              shift and go to state 58
    term                           shift and go to state 60
    factor                         shift and go to state 62

state 97

    (30) print_list_tail -> empty .

    )               reduce using rule 30 (print_list_tail -> empty .)


state 98

    (12) params -> ID : type params_tail .

    )               reduce using rule 12 (params -> ID : type params_tail .)


state 99

    (14) params_tail -> , . ID : type params_tail

    ID              shift and go to state 116


state 100

    (15) params_tail -> empty .

    )               reduce using rule 15 (params_tail -> empty .)


state 101

    (11) func -> VOID ID ( params ) [ vars . body ] ;
    (16) body -> . { stmt_list }

    {               shift and go to state 22

    body                           shift and go to state 117

state 102

    (41) expression -> simple_expression > simple_expression .
    (44) simple_expression -> simple_expression . + term
    (45) simple_expression -> simple_expression . - term

    ;               reduce using rule 41 (expression -> simple_expression > simple_expression .)
    ,               reduce using rule 41 (expression -> simple_expression > simple_expression .)
    )               reduce using rule 41 (expression -> simple_expression > simple_expression .)
    +               shift and go to state 81
    -               shift and go to state 82


state 103

    (42) expression -> simple_expression < simple_expression .
    (44) simple_expression -> simple_expression . + term
    (45) simple_expression -> simple_expression . - term

    ;               reduce using rule 42 (expression -> simple_expression < simple_expression .)
    ,               reduce using rule 42 (expression -> simple_expression < simple_expression .)
    )               reduce using rule 42 (expression -> simple_expression < simple_expression .)
    +               shift and go to state 81
    -               shift and go to state 82


state 104

    (43) expression -> simple_expression NE simple_expression .
    (44) simple_expression -> simple_expression . + term
    (45) simple_expression -> simple_expression . - term

    ;               reduce using rule 43 (expression -> simple_expression NE simple_expression .)
    ,               reduce using rule 43 (expression -> simple_expression NE simple_expression .)
    )               reduce using rule 43 (expression -> simple_expression NE simple_expression .)
    +               shift and go to state 81
    -               shift and go to state 82


state 105

    (44) simple_expression -> simple_expression + term .
    (47) term -> term . * factor
    (48) term -> term . / factor

    >               reduce using rule 44 (simple_expression -> simple_expression + term .)
    <               reduce using rule 44 (simple_expression -> simple_expression + term .)
    NE              reduce using rule 44 (simple_expression -> simple_expression + term .)
    +               reduce using rule 44 (simple_expression -> simple_expression + term .)
    -               reduce using rule 44 (simple_expression -> simple_expression + term .)
    ;               reduce using rule 44 (simple_expression -> simple_expression + term .)
    ,               reduce using rule 44 (simple_expression -> simple_expression + term .)
    )               reduce using rule 44 (simple_expression -> simple_expression + term .)
    *               shift and go to state 84
    /               shift and go to state 85


state 106

    (45) simple_expression -> simple_expression - term .
    (47) term -> term . * factor
    (48) term -> term . / factor

    >               reduce using rule 45 (simple_expression -> simple_expression - term .)
    <               reduce using rule 45 (simple_expression -> simple_expression - term .)
    NE              reduce using rule 45 (simple_expression -> simple_expression - term .)
    +               reduce using rule 45 (simple_expression -> simple_expression - term .)
    -               reduce using rule 45 (simple_expression -> simple_expression - term .)
    ;               reduce using rule 45 (simple_expression -> simple_expression - term .)
    ,               reduce using rule 45 (simple_expression -> simple_expression - term .)
    )               reduce using rule 45 (simple_expression -> simple_expression - term .)
    *               shift and go to state 84
    /               shift and go to state 85


state 107

    (47) term -> term * factor .

    *               reduce using rule 47 (term -> term * factor .)
    /               reduce using rule 47 (term -> term * factor .)
    >               reduce using rule 47 (term -> term * factor .)
    <               reduce using rule 47 (term -> term * factor .)
    NE              reduce using rule 47 (term -> term * factor .)
    +               reduce using rule 47 (term -> term * factor .)
    -               reduce using rule 47 (term -> term * factor .)
    ;               reduce using rule 47 (term -> term * factor .)
    ,               reduce using rule 47 (term -> term * factor .)
    )               reduce using rule 47 (term -> term * factor .)


state 108

    (48) term -> term / factor .

    *               reduce using rule 48 (term -> term / factor .)
    /               reduce using rule 48 (term -> term / factor .)
    >               reduce using rule 48 (term -> term / factor .)
    <               reduce using rule 48 (term -> term / factor .)
    NE              reduce using rule 48 (term -> term / factor .)
    +               reduce using rule 48 (term -> term / factor .)
    -               reduce using rule 48 (term -> term / factor .)
    ;               reduce using rule 48 (term -> term / factor .)
    ,               reduce using rule 48 (term -> term / factor .)
    )               reduce using rule 48 (term -> term / factor .)


state 109

    (50) factor -> ( expression ) .

    *               reduce using rule 50 (factor -> ( expression ) .)
    /               reduce using rule 50 (factor -> ( expression ) .)
    >               reduce using rule 50 (factor -> ( expression ) .)
    <               reduce using rule 50 (factor -> ( expression ) .)
    NE              reduce using rule 50 (factor -> ( expression ) .)
    +               reduce using rule 50 (factor -> ( expression ) .)
    -               reduce using rule 50 (factor -> ( expression ) .)
    ;               reduce using rule 50 (factor -> ( expression ) .)
    ,               reduce using rule 50 (factor -> ( expression ) .)
    )               reduce using rule 50 (factor -> ( expression ) .)


state 110

    (35) f_call -> ID ( expr_list ) ; .

    ID              reduce using rule 35 (f_call -> ID ( expr_list ) ; .)
    IF              reduce using rule 35 (f_call -> ID ( expr_list ) ; .)
    WHILE           reduce using rule 35 (f_call -> ID ( expr_list ) ; .)
    PRINT           reduce using rule 35 (f_call -> ID ( expr_list ) ; .)
    }               reduce using rule 35 (f_call -> ID ( expr_list ) ; .)


state 111

    (38) expr_list_tail -> , expression . expr_list_tail
    (38) expr_list_tail -> . , expression expr_list_tail
    (39) expr_list_tail -> . empty
    (56) empty -> .

    ,               shift and go to state 90
    )               reduce using rule 56 (empty -> .)

    expr_list_tail                 shift and go to state 118
    empty                          shift and go to state 91

state 112

    (32) condition -> IF ( expression ) body . else_part ;
    (33) else_part -> . ELSE body
    (34) else_part -> . empty
    (56) empty -> .

    ELSE            shift and go to state 120
    ;               reduce using rule 56 (empty -> .)

    else_part                      shift and go to state 119
    empty                          shift and go to state 121

state 113

    (31) cycle -> WHILE ( expression ) DO . body ;
    (16) body -> . { stmt_list }

    {               shift and go to state 22

    body                           shift and go to state 122

state 114

    (25) print_stmt -> PRINT ( print_list ) ; .

    ID              reduce using rule 25 (print_stmt -> PRINT ( print_list ) ; .)
    IF              reduce using rule 25 (print_stmt -> PRINT ( print_list ) ; .)
    WHILE           reduce using rule 25 (print_stmt -> PRINT ( print_list ) ; .)
    PRINT           reduce using rule 25 (print_stmt -> PRINT ( print_list ) ; .)
    }               reduce using rule 25 (print_stmt -> PRINT ( print_list ) ; .)


state 115

    (29) print_list_tail -> , print_item . print_list_tail
    (29) print_list_tail -> . , print_item print_list_tail
    (30) print_list_tail -> . empty
    (56) empty -> .

    ,               shift and go to state 96
    )               reduce using rule 56 (empty -> .)

    print_list_tail                shift and go to state 123
    empty                          shift and go to state 97

state 116

    (14) params_tail -> , ID . : type params_tail

    :               shift and go to state 124


state 117

    (11) func -> VOID ID ( params ) [ vars body . ] ;

    ]               shift and go to state 125


state 118

    (38) expr_list_tail -> , expression expr_list_tail .

    )               reduce using rule 38 (expr_list_tail -> , expression expr_list_tail .)


state 119

    (32) condition -> IF ( expression ) body else_part . ;

    ;               shift and go to state 126


state 120

    (33) else_part -> ELSE . body
    (16) body -> . { stmt_list }

    {               shift and go to state 22

    body                           shift and go to state 127

state 121

    (34) else_part -> empty .

    ;               reduce using rule 34 (else_part -> empty .)


state 122

    (31) cycle -> WHILE ( expression ) DO body . ;

    ;               shift and go to state 128


state 123

    (29) print_list_tail -> , print_item print_list_tail .

    )               reduce using rule 29 (print_list_tail -> , print_item print_list_tail .)


state 124

    (14) params_tail -> , ID : . type params_tail
    (7) type -> . INT
    (8) type -> . FLOAT

    INT             shift and go to state 25
    FLOAT           shift and go to state 26

    type                           shift and go to state 129

state 125

    (11) func -> VOID ID ( params ) [ vars body ] . ;

    ;               shift and go to state 130


state 126

    (32) condition -> IF ( expression ) body else_part ; .

    ID              reduce using rule 32 (condition -> IF ( expression ) body else_part ; .)
    IF              reduce using rule 32 (condition -> IF ( expression ) body else_part ; .)
    WHILE           reduce using rule 32 (condition -> IF ( expression ) body else_part ; .)
    PRINT           reduce using rule 32 (condition -> IF ( expression ) body else_part ; .)
    }               reduce using rule 32 (condition -> IF ( expression ) body else_part ; .)


state 127

    (33) else_part -> ELSE body .

    ;               reduce using rule 33 (else_part -> ELSE body .)


state 128

    (31) cycle -> WHILE ( expression ) DO body ; .

    ID              reduce using rule 31 (cycle -> WHILE ( expression ) DO body ; .)
    IF              reduce using rule 31 (cycle -> WHILE ( expression ) DO body ; .)
    WHILE           reduce using rule 31 (cycle -> WHILE ( expression ) DO body ; .)
    PRINT           reduce using rule 31 (cycle -> WHILE ( expression ) DO body ; .)
    }               reduce using rule 31 (cycle -> WHILE ( expression ) DO body ; .)


state 129

    (14) params_tail -> , ID : type . params_tail
    (14) params_tail -> . , ID : type params_tail
    (15) params_tail -> . empty
    (56) empty -> .

    ,               shift and go to state 99
    )               reduce using rule 56 (empty -> .)

    params_tail                    shift and go to state 131
    empty                          shift and go to state 100

state 130

    (11) func -> VOID ID ( params ) [ vars body ] ; .

    VOID            reduce using rule 11 (func -> VOID ID ( params ) [ vars body ] ; .)
    MAIN            reduce using rule 11 (func -> VOID ID ( params ) [ vars body ] ; .)


state 131

    (14) params_tail -> , ID : type params_tail .

    )               reduce using rule 14 (params_tail -> , ID : type params_tail .)

